1)	Как организован механизм генерации случайных чисел в библиотеке random?
Генератор псевдослучайных чисел С++ 11
Rand() -> [0; Intmax], нарушает равномерность распределения, второй минус – низкая скорость работы, третий минус - зацикливание.
Chrono(random::device) -> seed -> генератор -> (создает случайные значения [0, intmax]) -> распределение –> (случайное число)

2)	Чем отличаются функциональные объекты от функций и лямбда выражений?
Предикат – функциональный объект, который возвращает true или false и не сохраняет состояние (некоторое св-во, которое сохраняется между вызовами)
Передается как данные (быстрее)

•	Функциональный объект может быть более интеллектуальным, обладать большими возможностями, потому что у него есть состояние 
•	Каждый функциональный объект имеет свой тип 
•	Функциональный объект обычно работает быстрее, чем указатель на функцию


Функциональный объект – это класс/структура с перегруженным оператором круглые скобки
Состояние: данные члены

Если сравнивать функциональный объект с лямбда функцией, то с точки зрения вызовов пользовательский функциональный объект можно считать более компактным и менее подверженным ошибкам, чем лямбда функция. Как и функциональные объекты, лямбда выражения позволяют хранить состояния, но их компактный синтаксис в отличие от функциональных объектов не требует объявления класса 

Функциональный объект работает быстрее функции, переданной через указатель 
Функции состояние: глобальная переменная, аргумент по ссылке(отличный способ т.к мы контролируем время жизни), статическая переменная(мы не контроллируем время ее жизни)


3)	Какими наборами возможностей обладают итераторы различных категорий?
Что такое итераторы?
Итераторы – связующее звено между контейнерами и алгоритмами.
Категории итераторов:
•	Input Iterator  ==, !=, ++, =, *, -> (чтение) ex: istream_iterator (итераторы потока)
•	Output Iterator  ==, !=, ++, =, *, -> (запись) ex: ostream_iterator (итераторы потока)
•	Forward_iterator, имеет все св-ва Input и output + многопроходность ex: forward_list
•	Bidirertional_Iterator, свойства FI, --;  ex: list, map, set
•	Random_Access_Iterator, свойства BI, + - n   ex: vector, deque
•	Istream_iterator – итератор ввода
•	Ostream_iterator – оператор вывода
Итераторы можно сдвигать вправо, влево
Std::next, std::prev (возвращают копию) (it, N); next – вправо, prev – влево
Std::advance (тоже самое, только меняет исходный итератор) (сдвигает вправо или влево меняет не копию, а сам итератор)
Std::distance (определяет дистанцию) (it_1, it_2);
Адаптеры итераторов:
•	Reverse итераторы 
•	Итераторы вставки – для insert
•	Move итераторы
Std::copy (v1.begin(), v1.end(), v2.begin()) выполняет “=”, а не push.back/insert
Итераторы вставки делают back.iterator. front.
(Алгоритмы делают = )

 
4)	Какая классификация предлагается для алгоритмов стандартной библиотеки?
Во-первых:
•	алгоритмы работают с диапазонами через итераторы
•	работают в режиме замены, а не вставки
•	можно передавать пользовательские операции
Классификация алгоритмов:
1.	Немодифицирующие алгоритмы
Std::for_each – конкурент range based for
Std::Count_if – подсчитывает количество элементов, удовл условиям
Std::minmax_element (есть минимум и максимум)
Std::find_if  (много других поисков)


2.	Модифицирующие алгоритмы
Std::for_each
Std::copy/copy_if/unique_copy
Std::transfor;  -; =  -   (одну последовательность в одну, две последовательности в одну)
Std::iota (0, 1, 2, 3..)
Std::generate – случайные числа
Std::replace_if
Std::fill_n

3.	Алгоритмы удаления
Std::remove_if – делает перестановку 
Std::unique – удаляет в отсортированной последовательности повторяющиеся 

4.	Алгоритм перестановки
Std::reverse 
Std::shuffle (random_shuffle устаревший) 
Std::rotate – циклический сдвиг

5.	Алгоритмы сортировки
Std::sort  
Std::nth_element  - выполняет неполную сортировку 

6.	Для упорядоченных диапазонов (лучше всего работает бинарный поиск на упорядоченных диапазонах)
Binary_search 
Upper_bound
Lower_bound
Equal_range 

7.	Операции на множествах
8.	Численные алгоритмы (include <numeric>)
Std::accumulate  - считает  сумму элементов 

5)	Почему алгоритмы стандартной библиотеки предпочтительнее собственных?
Алгоритмы библиотеки обладают большей скоростью, меньшим кодом и простотой. 
