1)	В каких ситуациях применяют типы std::pair и std::tuple
Стоит сказать, что std::pair может иметь только два члена данных, компонентами могут выступать .first, .second, make_pair()
Std::pair используется для хранения пар

Std::tuple может иметь более двух пар, tuple – расширенная концепция пар на произвольное количество элементов. В качестве компонентов могут выступать: get, make_tuple и др
Отметим, что двухэлементный кортеж можно инициализировать объектом типа pair. Кроме того, можно присваивать объект типа pair двухэлементному котрежу.
Класс Pair<> содержит специальный конструктор для инициализации его элементов с помощью котрежей.

2)	Когда следует использовать контейнер std::array?
Std::array <T, N> - фиксированный массив, память располагается на стеке, является более безопасным по сравнению со встроенным массивом.
Массивы копируют свои элементы во внутренний статический массив. Элементы всегда располагаются в определенном порядке, т.е массивы  разновидность упорядоченной коллекции, пользователь может получить прямой доступ к каждому элементу массива за константное время, при условии, что он знает его позицию

3)	Когда следует использовать std::vector?
Во-первых, vector – динамический массив, элементы вектора всегда располагаются в определенном порядке, таким образом, вектор – разновидность упорядоченной коллекции(подобно array). Векторы обеспечивают хорошую производительность, если вставка или удаление элементов происходит в конце.
Почему вектор имеет хорошую производительность? Одна из причин заключается в выделении большого объема памяти, чем требуется для хранения всех элементов.
Над векторами можно проводить создание, копирование, удаление 

4)	Когда следует использовать std::deque?
Std::deque – двусторонняя очередь, идеально подходит для операций вставок с двух концов 

5)	Когда следует использовать std::list?
Std::list – двусвязный список, подходит для вставки и удаления элементов в произвольное место.
Стоит отметить, что внутренняя структура списка отлична от внутренней структуры array, вектора или дека, объект списка содержит два указателя – якоря, ссылающийся на первый и последний элемент, каждый элемент содержит указатель на предыдущий и следующий элементы

6)	Когда следует использовать std::forward_list?
Std::forward_list – это односвязный список, этот список обладает тем свойством, что от него требуется максимальная экономия памяти, в связи с этим даже нет size(), существуют только однонаправленные итераторы, якорь последовательного списка не имеет указатель на последний элемент, в связи с этим в списке не подразумевается использовать back, push_back, pop_back

7)	Какие адаптеры контейнеров есть в стандартной библиотеке?
•	Стек (LIFO)
•	Очередь (FIFO)
•	Очередь с приоритетом (FIFO + sort) 

8)	Когда следует использовать контейнер circular buffer из boost
Circular buffer – циклический буфер, удобно использовать для хранения истории фиксированной длины при постоянном поступлении новых данных, когда все ячейки buffer заполняются, то ячейки начинают перезаписываться с начала

9)	Почему контейнер circular buffer из boost не может войти в стандартную библиотеку?
Не сможет войти, т.к возможна ситуация, когда begin > end

10)	Какие типы данных для работы с многомерными массивами вы можете назвать?
•	Вектор векторов (vector vector)
•	Multiarray
•	Обычный массив
